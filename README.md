# k8s-setup
Technical Assessment

# Kubernetes Cluster Setup and Document Similarity Web Application

This project demonstrates the setup of a Kubernetes cluster using Ansible and Helm to deploy a web application that compares the similarity of legal documents using embeddings created by a third-party API. The application is designed to be scalable and can be extended to use local GPU-enabled machines for future versions.

## Repository Structure
```
k8s-cluster-setup/
├── ansible/
│   ├── k8s-setup.yml
│   ├── inventory.ini
│   ├── roles/
│   │   ├── common/
│   │   │   ├── tasks/
│   │   │   │   └── main.yml
│   │   ├── master/
│   │   │   ├── tasks/
│   │   │   │   └── main.yml
│   │   └── worker/
│   │       ├── tasks/
│   │       │   └── main.yml
├── helm/
│   ├── Chart.yaml
│   ├── templates/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   └── values.yaml
├── README.md
```
## Key Components

### Ansible

#### `ansible/playbook.yml`
Ansible playbook to set up a Kubernetes cluster. This playbook automates the provisioning and configuration of master and worker nodes.

#### `ansible/inventory.ini`
Inventory file containing details of the master and worker nodes. This file specifies the IP addresses and SSH details for the nodes.


#### common/tasks/main.yaml
This file contains tasks that are common to both master and worker nodes. These tasks usually involve installing necessary dependencies, setting up networking, and configuring system settings that are required on all nodes in the Kubernetes cluster.

#### master/tasks/main.yaml
This file contains tasks specific to setting up the master node in the Kubernetes cluster. This includes initializing the Kubernetes master, setting up the API server, controller manager, scheduler, and generating the `kubeadm` join command for worker nodes to join the cluster.

#### worker/tasks/main.yaml
file contains tasks specific to setting up the worker nodes in the Kubernetes cluster. This includes joining the worker nodes to the Kubernetes cluster using the `kubeadm join` command generated by the master node.

### Helm

```
dummy-app/
├── Chart.yaml
├── templates/
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   ├── hpa.yaml
│   ├── serviceaccount.yaml
│   ├── _helpers.tpl
│   └── tests/
│       └── test-connection.yaml
└── values.yaml
```

#### Chart.yaml:
Contains metadata about the Helm chart, such as the name, version, and description.

#### values.yaml:
Defines the default values for the Helm chart. These values can be overridden by users during the installation process. It includes configurations for replica count, image details, service type, ingress settings, resource limits, and autoscaling.

#### templates/deployment.yaml:
Defines the Kubernetes Deployment resource. This file specifies the deployment configuration for the web application, including the number of replicas, container image, ports, probes, and resource limits.

#### templates/service.yaml:
Defines the Kubernetes Service resource. This file specifies the configuration for exposing the web application internally within the cluster.

#### templates/ingress.yaml:
Defines the Kubernetes Ingress resource. This file specifies the ingress configuration for managing external access to the web application.

#### templates/hpa.yaml:
Defines the Kubernetes Horizontal Pod Autoscaler (HPA) resource. This file specifies the autoscaling configuration for the deployment, based on CPU utilization or other metrics.

#### templates/serviceaccount.yaml:
Defines the Kubernetes ServiceAccount resource. This file specifies the service account configuration for the deployment, including any necessary annotations and permissions.

#### templates/_helpers.tpl:
Contains template helper functions that are used in other template files. These functions help generate names, labels, and other template values.

#### templates/tests/test-connection.yaml:
Defines a Kubernetes Pod resource for testing the connection to the deployed service. This file specifies a test pod that uses the `busybox` image to verify that the service is accessible.

## Instructions

####  Set Up Kubernetes Cluster
Use the Ansible playbook to provision the Kubernetes cluster.
```
ansible-playbook -i ansible/inventory.ini ansible/playbook.yml
```
#### Install Helm
Install Helm on local machine.
```
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
```
#### Deploy Application
Use the Helm Chart to deploy the web application into the Kubernetes cluster.
```
helm install myapp ./dummy-app
```

#### Verify Deployment
Ensure that the application is running and accessible through the configured Ingress using `kubectl`
```
kubectl get all -l app.kubernetes.io/name=myapp
```
#### Run Connection Test
Run the Helm test to verify that the service is accessible.
```
helm test myapp
```
#### Future Work
Integrate GPU Workloads: Extend the current setup to deploy containers using GPUs for creating embeddings.
Performance Optimization: Monitor the application's performance and optimize resource allocation.
Security Enhancements: Implement network policies and role-based access control (RBAC) for enhanced security.
